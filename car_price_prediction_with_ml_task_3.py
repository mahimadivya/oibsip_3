# -*- coding: utf-8 -*-
"""car price prediction with ML.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GU9xcrjAXaxISQBYWaPWmCehcCMN4AZ4
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

df=pd.read_csv('CarPrice.csv')

df.head()

df.shape

df.columns

df.dtypes

df.drop('car_ID', inplace=True, axis=1 )

CompanyName = df['CarName'].apply(lambda x : x.split(' ')[0])
df.insert(3,"CompanyName",CompanyName)
df.drop(['CarName'],axis=1,inplace=True)
df.head()

df.CompanyName.unique()

df.CompanyName = df.CompanyName.str.lower()

def  name(a,b):
    df.CompanyName.replace(a,b,inplace=True)

name('maxda','mazda')
name('porcshce','porsche')
name('toyouta','toyota')
name('vokswagen','volkswagen')
name('vw','volkswagen')

df.CompanyName.unique()

df.isnull().sum()

df.describe()

import seaborn as sns
plt.figure(figsize=(20,10))
sns.heatmap(df.corr(),annot=True)

df.plot(kind='box', subplots=True, layout=(5, 5), figsize=(14, 14))

Q1 = df.quantile(0.25)
Q3 = df.quantile(0.75)
IQR = Q3 - Q1
((df < (Q1 - 1.5 * IQR)) | (df > (Q3 + 1.5 * IQR))).sum().sort_values(ascending=False)

def outlier_detect(df):
    for i in df.describe().columns:
        Q1=df.describe().at['25%',i]
        Q3=df.describe().at['75%',i]
        IQR=Q3 - Q1
        LTV=Q1 - 1.5 * IQR
        UTV=Q3 + 1.5 * IQR
        x=np.array(df[i])
        p=[]
        for j in x:
            if j < LTV or j>UTV:
                p.append(df[i].median())
            else:
                p.append(j)
        df[i]=p
    return df

outlier_detect(df)

col_list = []
for col in df.columns:
    if ((df[col].dtype == 'object') ):
        col_list.append(col)

from sklearn.preprocessing import LabelEncoder
labelencoder = LabelEncoder()
for i in col_list:
    df[i]=labelencoder.fit_transform(df[i])

from statsmodels.stats.outliers_influence import variance_inflation_factor
def calc_vif(X):

    # Calculating VIF
    vif = pd.DataFrame()
    vif["variables"] = X.columns
    vif["VIF"] = [variance_inflation_factor(X.values, i) for i in range(X.shape[1])]

    return(vif)

calc_vif(df)

df.drop(columns=['doornumber','aspiration' ,'symboling' ,'doornumber','enginelocation'], inplace=True, axis=1) #'aspiration' 'symboling' 'doornumber'

x=df.drop(columns=['price'], axis=1)
y=df['price']
#print(x.head())
#print(y.head())

from sklearn.model_selection import train_test_split
X_train, X_test, y_train,y_test = train_test_split(x,y,test_size = 0.20, random_state = 1)

print(X_train.shape)
print(X_test.shape)
print(y_train.shape)
print(y_test.shape)

from sklearn.preprocessing import StandardScaler
sc=StandardScaler()
X_train=sc.fit_transform(X_train)
X_test=sc.transform(X_test)

from sklearn.linear_model import LinearRegression
model= LinearRegression()

model.fit(X_train,y_train)

# constant (b - bias)
model.intercept_

# coefficients (w - weights)
model.coef_

y_pred=model.predict(X_test)
y_pred.dtype

from sklearn.metrics import r2_score,mean_squared_error
mse=mean_squared_error(y_test,y_pred)
rmse=np.sqrt(mse)
print(rmse)
r2_score=r2_score(y_test,y_pred)
print(r2_score*100)

from sklearn.tree import DecisionTreeRegressor
DTRmodel = DecisionTreeRegressor(max_depth=5,random_state=0)
DTRmodel.fit(X_train,y_train)
y_pred1 = DTRmodel.predict(X_test)

print('Accuracy:',DTRmodel.score(X_test, y_test)*100)

from sklearn.ensemble import RandomForestRegressor
rf1 = RandomForestRegressor(n_estimators=500, random_state=42, n_jobs=5, max_depth=15)
rf1.fit(X_train,y_train)
y_pred1 = rf1.predict(X_test)

print('Accuracy:',rf1.score(X_test, y_test)*100)

train_score = rf1.score(X_train, y_train)

# Calculate the R-squared value for the test data
test_score = rf1.score(X_test, y_test)

# Print the R-squared values for both the train and test data
print("R-squared value for train data:", train_score*100)
print("R-squared value for test data:", test_score*100)

act_predict= pd.DataFrame({
    'Actual': y_test.values.flatten(),
    'Predict': y_pred.flatten()})
act_predict.head(5)

